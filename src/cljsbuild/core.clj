(ns cljsbuild.core
  (:use
    [clojure.java.io :only [as-url resource]]
    [clj-stacktrace.repl :only [pst+]]
    [cljs.closure :only [build]])
  (:require
    [clojure.string :as string]
    [fs.core :as fs]))

(def lock (Object.))

(defn- println-safe
  [& args]
  (locking lock
    (apply println args)
    (flush)))

(defn- join-paths [& paths]
  (apply str (interpose "/" paths)))

(defn- separate [pred coll]
  (let [separated (group-by pred coll)]
    [(separated true) (separated false)]))

(defmacro dofor [seq-exprs body-expr]
  `(doall (for ~seq-exprs ~body-expr)))

(defn- fail [& args]
  (throw (Exception. (apply str args))))

(defn- truncate-uri-path [uri n]
  (if uri
    (let [uri-path (.getPath uri)]
      (subs uri-path 0 (- (.length uri-path) n)))
    nil))

(defn- ns-to-path [ns]
  (let [underscored (string/replace (str ns) #"-" "_")]
    (apply join-paths
      (string/split underscored #"\."))))

(defn- filter-cljs [files types]
  (let [ext #(last (string/split % #"\."))]
    (filter #(types (ext %)) files)))

(defn- find-dir-cljs [root files types]
  (for [cljs (filter-cljs files types)]
    (join-paths root cljs)))

(defn- find-cljs [dir types]
  (let [iter (fs/iterate-dir dir)]
    (mapcat
      (fn [[root _ files]]
        (find-dir-cljs root files types))
      iter)))

(defn- elapsed [started-at]
  (let [elapsed-us (- (. System (nanoTime)) started-at)]
    (with-precision 2
      (str (/ (double elapsed-us) 1000000000) " seconds"))))

(defn- compile-cljs [cljs-path compiler-options]
  (let [output-file (:output-to compiler-options)
        output-dir (fs/parent output-file)]
    (println-safe (str "Compiling " output-file " from " cljs-path "..."))
    (flush)
    (when output-dir
      (fs/mkdirs output-dir))
    (let [started-at (. System (nanoTime))]
      (try
        (build cljs-path compiler-options)
        (println-safe (str output-file " compiled in " (elapsed started-at) "."))
        (catch Throwable e
          (println-safe " Failed!")
          (pst+ e))))))

(defn- is-macro-file? [file]
  (not (neg? (.indexOf (slurp file) ";*CLJSBUILD-MACRO-FILE*;"))))

; There is a little bit of madness here to share macros between Clojure
; and ClojureScript.  The latter needs a  (:require-macros ...) whereas the
; former just wants  (:require ...).  Thus, we have a ;*CLJSBUILD-REMOVE*;
; conditional comment to allow different code to be used for ClojureScript files.
(defn- filtered-crossover-file [file]
  (str
    "; DO NOT EDIT THIS FILE! IT WAS AUTOMATICALLY GENERATED BY\n"
    "; lein-cljsbuild FROM THE FOLLOWING SOURCE FILE:\n"
    "; " file "\n\n"
    (string/replace (slurp file) ";*CLJSBUILD-REMOVE*;" "")))

(defn- crossover-to [cljs-path [from-parent from-resource]]
  (let [subpath (string/replace-first
                  (fs/absolute-path (.getPath from-resource))
                  (fs/absolute-path from-parent) "")
        to-file (fs/normalized-path
                  (join-paths (fs/absolute-path cljs-path) subpath))]
    (string/replace to-file #"\.clj$" ".cljs")))

(defn- recurse-resource-dir [dir]
  (if dir
    ; We can't determine the contents of a jar dir.  Thus, crossover files
    ; in jars cannot be specified recursively; they have to be named file
    ; by file.
    (if (= (.getProtocol dir) "file")
      (let [files (find-cljs (.getPath dir) #{"clj"})]
        (map #(as-url (str "file:" %)) files))
      [dir])))

(defn- find-crossover [crossover]
  (let [ns-path (ns-to-path crossover)
        as-dir (resource ns-path)
        dir-parent (truncate-uri-path as-dir (.length ns-path))
        recurse-dirs (recurse-resource-dir as-dir)
        ns-file-path (str ns-path ".clj")
        as-file (resource ns-file-path)
        file-parent (truncate-uri-path as-file (.length ns-file-path))
        resources (conj
                    (map vector (repeat dir-parent) recurse-dirs)
                    [file-parent as-file])]
    (when (empty? resources)
      (fail "Unable to find crossover: " crossover))
    resources))

(defn- find-crossovers [crossovers]
  (distinct
    (remove #(nil? (second %))
      (mapcat find-crossover crossovers))))

(defn- crossover-needs-update? [from-resource to-file]
  (let [exists (fs/exists? to-file)]
    (or
      (not exists)
      (and
        ; We can't determine the mtime for jar resources; they'll just
        ; be copied once and that's it.
        (= "file" (.getProtocol from-resource))
        (> (fs/mod-time (.getPath from-resource)) (fs/mod-time to-file))))))

(defn- copy-crossovers [cljs-path from-resources]
  (let [to-files (map (partial crossover-to cljs-path) from-resources)]
    (doseq [dir (distinct (map fs/parent to-files))]
      (fs/mkdirs dir))
    (dofor [[[_ from-resource] to-file] (zipmap from-resources to-files)]
      (when (crossover-needs-update? from-resource to-file)
        (spit to-file (filtered-crossover-file from-resource))
        :updated))))

(defn in-threads
  "Given a seq and a function, applies the function to each item in a different thread
and returns a seq of the results. Launches all the threads at once."
  [f s]
  (doall (map deref (doall (map #(future (f %)) s)))))

(defn run-compiler [cljs-path crossovers compiler-options watch?]
  (loop [last-dependency-mtimes {}]
    (let [output-file (:output-to compiler-options)
          output-mtime (if (fs/exists? output-file) (fs/mod-time output-file) 0)
          crossover-resources (find-crossovers crossovers)
          [crossover-macros crossover-plains] (separate
                                                #(is-macro-file? (second %))
                                                crossover-resources)
          crossover-macro-files (map #(.getPath (second %)) crossover-macros)
          cljs-files (find-cljs cljs-path #{"cljs"})
          dependency-mtimes (map fs/mod-time
                              (concat crossover-macro-files cljs-files))
          crossover-updated? (some #{:updated}
                               (copy-crossovers cljs-path crossover-plains))]
      (when (or
              (and
                (not= last-dependency-mtimes dependency-mtimes)
                (some #(< output-mtime %) dependency-mtimes))
              crossover-updated?)
        (compile-cljs cljs-path compiler-options))
      (when watch?
        (Thread/sleep 100)
        (recur dependency-mtimes)))))

(defn cleanup-files [cljs-path crossovers compiler-options]
  (fs/delete (:output-to compiler-options))
  (fs/delete-dir (:output-dir compiler-options))
  (let [from-resources (find-crossovers crossovers)
        to-files (map (partial crossover-to cljs-path) from-resources)]
    (doseq [file to-files]
      (fs/delete file))))
